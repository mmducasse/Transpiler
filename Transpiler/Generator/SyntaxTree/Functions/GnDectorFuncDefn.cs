using Transpiler.Analysis;
using static Transpiler.Extensions;

namespace Transpiler.Generate
{
    public record GnDectorFuncDefn(string ElementName,
                                   int ElementIndex,
                                   IGnFuncExpn Expression,
                                   bool InvokeImmediately) : IGnFuncStmtDefn
    {
        public string Name => ElementName;

        public static GnDectorFuncDefn Prepare(IScope scope, AzDectorFuncDefn azDectorDefn)
        {
            var expn = IGnFuncExpn.Prepare(scope, azDectorDefn.Expression);

            var tvs = azDectorDefn.Type.GetTypeVars();
            if (tvs.Count > 0)
            {
                foreach (var tv in tvs)
                {
                    foreach (var r in tv.Refinements)
                    {
                        var param = new GnParam("d" + r.Name + tv.Name, IsAutoGenerated: true);
                        expn = new GnLambdaExpn(param, expn);
                    }
                }
            }

            return new(azDectorDefn.ElementName, azDectorDefn.ElementIndex, expn, azDectorDefn.InvokeImmediately);
        }

        public string Generate(int i, NameProvider names, ref string s)
        {
            return Generate(i, names, "", ref s);
        }

        public string Generate(int i, NameProvider names, string namePrefix, ref string s)
        {
            string name = namePrefix.Generated() + Name.SafeNameGenerated();
            s += string.Format("{0}function {1}() {{\n", Indent(i), name);
            string expnRes = Expression.Generate(i + 1, names, ref s);
            s += string.Format("{0}return Get({1}, {2})\n", Indent(i + 1), ElementIndex, expnRes);
            s += Indent(i) + "}\n";

            return name;
        }
    }
}
