using System;
using System.Collections.Generic;
using Transpiler.Analysis;

namespace Transpiler.Generate
{
    public record GnSymbolExpn(string Name,
                               bool NeedsInvoke,
                               IReadOnlyList<string> TypeParameters,
                               bool IsAutoGenerated) : IGnFuncExpn, IGnPattern, IGnInlineNode
    {
        public static GnSymbolExpn Prepare(IScope scope, AzSymbolExpn symExpn)
        {
            bool needsInvoke = symExpn.Definition is not AzParam;
            bool isAutoGenerated = symExpn.Definition is AzParam param && param.IsAutoGenerated;

            List<string> typeParams = new();
            if (symExpn.Definition.Type != null &&
                symExpn.Definition.Type.GetRefinements().Count > 0)
            {
                var typeMapping = MapDefnTvsToCallTypes(symExpn.Definition, symExpn);
                foreach (var refinement in symExpn.Definition.Type.GetRefinements())
                {
                    var callTypeExpn = typeMapping[refinement.TypeVar];
                    string typeParamName = CreateTypeArgString(scope, refinement, callTypeExpn);
                    typeParams.Add(typeParamName);
                }
            }

            return new(symExpn.Definition.Name, needsInvoke, typeParams, isAutoGenerated);
        }

        public static IReadOnlyDictionary<TypeVariable, IAzTypeExpn>
            MapDefnTvsToCallTypes(IAzFuncDefn funcDefn, IAzFuncExpn funcExpn)
        {
            var funcDefnType = funcDefn.Type;
            var funcExpnType = funcExpn.Type;

            Dictionary<TypeVariable, IAzTypeExpn> mapping = new();

            MapNext(funcDefnType, funcExpnType);

            return mapping;

            void MapNext(IAzTypeExpn defnTypeExpn, IAzTypeExpn expnTypeExpn)
            {
                switch (defnTypeExpn, expnTypeExpn)
                {
                    case (TypeVariable dTv, _):
                        mapping[dTv] = expnTypeExpn;
                        break;

                    case (AzTypeLambdaExpn dLam, AzTypeLambdaExpn eLam):
                        MapNext(dLam.Input, eLam.Input);
                        MapNext(dLam.Output, eLam.Output);
                        break;

                    // Todo: add ctor and tuple cases.
                    case (AzTypeCtorExpn dCtor, AzTypeCtorExpn eCtor):
                        if (dCtor.TypeDefn != eCtor.TypeDefn) { throw new Exception(); }
                        break;

                    default:
                        throw new System.Exception();
                }
            }
        }

        private static string CreateTypeArgString(IScope scope, Refinement defnRef, IAzTypeExpn expnType)
        {
            if (expnType is AzTypeCtorExpn ctorExpn)
            {
                return string.Format("{0}_{1}", defnRef.ClassType.Name, ctorExpn.TypeDefn.Name);
            }
            else if (expnType is TypeVariable eTv)
            {
                foreach (var eRef in eTv.Refinements)
                {
                    string dictName = string.Format("d{0}{1}", eRef.Name, eTv.Name);
                    if (defnRef.ClassType == eRef)
                    {
                        return dictName;
                    }

                    if (scope.HasClassLineage(eRef, defnRef.ClassType, out var lineage))
                    {
                        string s = dictName;
                        for (int i = 1; i < lineage.Count; i++)
                        {
                            string funcName = string.Format("{0}From{1}", lineage[i].Name, lineage[i - 1].Name);
                            s = string.Format("{0}({1})", funcName, s.Generated());
                        }
                        return s;
                    }
                }
            }

            return "";

            //throw new Exception();
        }


        public string Generate(int i, NameProvider names, ref string s)
        {
            return Generate();
        }

        public string Generate()
        {
            string name = IsAutoGenerated
                ? Name.SafeName()
                : Name.SafeNameGenerated();

            if (NeedsInvoke)
            {
                var ps = TypeParameters.Separate(", ");
                return string.Format("{0}({1})", name, ps);
            }
            return name;
        }
    }
}
