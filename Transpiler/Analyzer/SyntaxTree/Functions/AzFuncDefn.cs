using System.Collections.Generic;
using System.Linq;
using Transpiler.Parse;
using static Transpiler.UI;

namespace Transpiler.Analysis
{
    // Todo: Add optional Type constraint property.
    public class AzFuncDefn : IAzFuncStmtDefn
    {
        public string Name { get; }

        public IAzTypeExpn Type { get; set; }

        public IAzFuncExpn Expression { get; set; }

        public eFixity Fixity { get; }

        public bool IsAutoGenerated { get; }

        public CodePosition Position { get; }

        public bool IsSolved { get; private set; }

        public AzFuncDefn(string name,
                          IAzTypeExpn typeExpression,
                          eFixity fixity,
                          bool isAutoGenerated,
                          CodePosition position)
        {
            Name = name;
            Type = typeExpression;
            Fixity = fixity;
            IsAutoGenerated = isAutoGenerated;
            Position = position;
        }

        public static AzFuncDefn Initialize(Scope scope,
                                            PsFuncDefn node)
        {
            // Analyze the function's explicit type, if it is provided.
            IAzTypeExpn explicitType = null;
            if (node.TypeExpression != null)
            {
                explicitType = IAzTypeExpn.Analyze(scope, node.TypeExpression);
            }

            var funcDefn = new AzFuncDefn(node.Name, explicitType, node.Fixity, false, node.Position);
            scope.AddFunction(funcDefn);
            return funcDefn;
        }

        public static AzFuncDefn Analyze(Scope parentScope,
                                         NameProvider names,
                                         TvProvider tvs,
                                         AzFuncDefn funcDefn,
                                         PsFuncDefn node)
        {
            var scope = new Scope(parentScope, "fn params");

            if (funcDefn.Type != null)
            {
                funcDefn.Type = funcDefn.Type.WithUniqueTvs(tvs);
            }
            else
            {
                funcDefn.Type = tvs.Next;
            }

            // Turn parameters into lambdas.
            var paramStack = new Stack<AzParam>();
            foreach (var param in node.Parameters)
            {
                var paramDefn = new AzParam(param.Name, false, tvs.Next, param.Position);
                scope.AddFunction(paramDefn);
                paramStack.Push(paramDefn);
            }

            var expn = IAzFuncExpn.Analyze(scope, names, tvs, node.Expression);

            while (paramStack.TryPop(out var paramDefn))
            {
                expn = new AzLambdaExpn(paramDefn, expn, tvs.Next, paramDefn.Position);
            }

            funcDefn.Expression = expn;

            return funcDefn;
        }

        public ConstraintSet Constrain(TvProvider provider,
                                       Scope scope)
        {
            if (Expression != null)
            {
                var cs = Expression.Constrain(provider, scope);
                var c = new Constraint(Type, Expression.Type, Position);

                return IConstraintSet.Union(c, cs);
            }

            return ConstraintSet.Empty;
        }

        public IAzFuncStmtDefn SubstituteType(Substitution s)
        {
            Type = Type.Substitute(s);
            Expression = Expression.SubstituteType(s);
            IsSolved = true;
            return this;
        }

        public IReadOnlyList<IAzFuncNode> GetSubnodes()
        {
            if (Expression == null)
            {
                return this.ToArr();
            }
            return this.ToArr().Concat(Expression.GetSubnodes()).ToList();
        }

        public virtual string Print(int i)
        {
            string type = (Type == null) ? "" : " :: " + Type.Print(0);
            var expn = (Expression == null) ? "" : " = " + Expression.Print(i + 1);
            return string.Format("{0}{1}{2}", Name, type, expn);
        }

        public void PrintSignature()
        {
            Pr("{0} :: ", Name);
            PrLn(Type.PrintWithRefinements(), foregroundColor: Yellow);
        }
    }
}
