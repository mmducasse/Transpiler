using System;
using System.Collections.Generic;
using System.Linq;
using Transpiler.Parse;
using static Transpiler.Extensions;

namespace Transpiler.Analysis
{
    public record AzMatchExpn(IAzFuncExpn Argument,
                              IReadOnlyList<AzMatchCase> Cases,
                              CodePosition Position) : IAzFuncExpn
    {
        public IAzTypeExpn Type { get; private set; } = TypeVariables.Next;

        public static IAzFuncExpn Analyze(Scope parentScope,
                                          NameProvider names,
                                          PsMatchExpn psMatExpn)
        {
            List<AzMatchCase> cases = new();
            foreach (var c in psMatExpn.Cases)
            {
                var scope = new Scope(parentScope, "<case>");
                var matchCase = AzMatchCase.Analyze(scope, names, c);
                cases.Add(matchCase);
            }

            if (psMatExpn.IsTerse)
            {
                AzParam param = new(names.Next, IsAutoGenerated: true, psMatExpn.Position);
                AzSymbolExpn symbol = new(param, param.Type, psMatExpn.Position);
                AzMatchExpn matchExpn = new(symbol, cases, psMatExpn.Position);
                AzScopedFuncExpn scopedExpn = new(matchExpn, RList<AzFuncDefn>(), parentScope, psMatExpn.Position);
                return new AzLambdaExpn(param, scopedExpn, psMatExpn.Position);
            }
            else
            {
                var arg = IAzFuncExpn.Analyze(parentScope, names, psMatExpn.Argument);

                return new AzMatchExpn(arg, cases, psMatExpn.Position);
            }
        }

        public ConstraintSet Constrain()
        {
            var csa = Argument.Constrain();

            var tmatch = Type;
            var targ = Argument.Type;

            var cs = new ConstraintSet();
            foreach (var @case in Cases)
            {
                var c = @case.Constrain();

                var tcase = @case.Type as AzTypeLambdaExpn;

                var cinput = new Constraint(targ, tcase.Input, Position);
                var coutput = new Constraint(tmatch, tcase.Output, Position);

                cs = IConstraintSet.Union(cs, c, cinput, coutput);
            }

            return IConstraintSet.Union(csa, cs);
        }

        public void SubstituteType(Substitution s)
        {
            Type = Type.Substitute(s);
        }

        public void Recurse(Action<IAzFuncNode> action)
        {
            Argument.Recurse(action);
            Cases.Foreach(c => c.Recurse(action));
            action(this);
        }

        public void ValidateCases()
        {
            int defaultCases = Cases.Where(c => c.Pattern is AzElsePattern).Count();
            if (defaultCases == 1) { return; }

            if (defaultCases > 1)
            {
                throw Analyzer.Error("Multiple default cases specified.", Position);
            }

            // No default case specified, make sure the match is exhaustive.
            if (Argument.Type is AzTypeCtorExpn typeCtorExpn &&
                typeCtorExpn.TypeDefn is AzUnionTypeDefn unionType)
            {
                var dataTypes = unionType.Subtypes.ToList();

                foreach (var @case in Cases)
                {
                    if (@case.Pattern is AzDectorPattern dectorPattern &&
                        dectorPattern.IsCompleteMember)
                    {
                        var dectorType = dectorPattern.TypeDefn;

                        dataTypes.Remove(dectorType);
                    }
                }

                if (dataTypes.Count > 0)
                {
                    throw Analyzer.Error("Non exhaustive match expressions must contain a default case.", Position);
                }
            }
        }

        public string Print(int i)
        {
            string s = string.Format("match {0}\n", Argument.Print(i));
            foreach (var c in Cases)
            {
                s += string.Format("{0}| {1}\n", Indent(i + 1), c.Print(i + 1));
            }

            return s;
        }
    }
}
