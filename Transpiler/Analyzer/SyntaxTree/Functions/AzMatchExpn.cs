using System.Collections.Generic;
using System.Linq;
using Transpiler.Parse;
using static Transpiler.Extensions;

namespace Transpiler.Analysis
{
    public record AzMatchExpn(IAzFuncExpn Argument,
                              IReadOnlyList<AzMatchCase> Cases,
                              IAzTypeExpn Type,
                              CodePosition Position) : IAzFuncExpn
    {
        public static IAzFuncExpn Analyze(Scope parentScope,
                                          NameProvider names,
                                          TvProvider tvs,
                                          PsMatchExpn psMatExpn)
        {
            List<AzMatchCase> cases = new();
            foreach (var c in psMatExpn.Cases)
            {
                var scope = new Scope(parentScope, "<case>");
                var matchCase = AzMatchCase.Analyze(scope, names, tvs, c);
                cases.Add(matchCase);
            }

            if (psMatExpn.IsTerse)
            {
                AzParam param = new(names.Next, IsAutoGenerated: true, tvs.Next, psMatExpn.Position);
                AzSymbolExpn symbol = new(param, param.Type, psMatExpn.Position);
                AzMatchExpn matchExpn = new(symbol, cases, tvs.Next, psMatExpn.Position);
                AzScopedFuncExpn scopedExpn = new(matchExpn, RList<AzFuncDefn>(), tvs.Next, parentScope, psMatExpn.Position);
                return new AzLambdaExpn(param, scopedExpn, tvs.Next, psMatExpn.Position);
            }
            else
            {
                var arg = IAzFuncExpn.Analyze(parentScope, names, tvs, psMatExpn.Argument);

                return new AzMatchExpn(arg, cases, tvs.Next, psMatExpn.Position);
            }
        }

        public ConstraintSet Constrain(TvProvider provider, Scope scope)
        {
            var csa = Argument.Constrain(provider, scope);

            var tmatch = Type;
            var targ = Argument.Type;

            var cs = new ConstraintSet();
            foreach (var @case in Cases)
            {
                var c = @case.Constrain(provider, scope);

                var tcase = @case.Type as AzTypeLambdaExpn;

                var cinput = new Constraint(targ, tcase.Input, Position);
                var coutput = new Constraint(tmatch, tcase.Output, Position);

                cs = IConstraintSet.Union(cs, c, cinput, coutput);
            }

            return IConstraintSet.Union(csa, cs);
        }

        public IReadOnlyList<IAzFuncNode> GetSubnodes()
        {
            var caseNodes = Cases.SelectMany(c => c.GetSubnodes()).ToList();
            return this.ToArr().Concat(Argument.GetSubnodes())
                               .Concat(caseNodes).ToList();
        }

        public IAzFuncExpn SubstituteType(Substitution s)
        {
            PostAnalyze();
            return new AzMatchExpn(Argument.SubstituteType(s),
                                   Cases.Select(c => c.SubstituteType(s)).ToList(),
                                   Type.Substitute(s),
                                   Position);
        }

        public void PostAnalyze()
        {
            int defaultCases = Cases.Where(c => c.Pattern is AzElsePattern).Count();
            if (defaultCases == 1) { return; }

            if (defaultCases > 1)
            {
                throw Analyzer.Error("Multiple default cases specified.", Position);
            }

            // No default case specified, make sure the match is exhaustive.
            if (Argument.Type is AzTypeCtorExpn typeCtorExpn &&
                typeCtorExpn.TypeDefn is AzUnionTypeDefn unionType)
            {
                var dataTypes = unionType.Subtypes.ToList();

                foreach (var @case in Cases)
                {
                    if (@case.Pattern is AzDectorPattern dectorPattern &&
                        dectorPattern.IsCompleteMember)
                    {
                        var dectorType = dectorPattern.TypeDefn;

                        dataTypes.Remove(dectorType);
                    }
                }

                if (dataTypes.Count > 0)
                {
                    throw Analyzer.Error("Non exhaustive match expressions must contain a default case.", Position);
                }
            }
        }

        public string Print(int i)
        {
            string s = string.Format("match {0}\n", Argument.Print(i));
            foreach (var c in Cases)
            {
                s += string.Format("{0}| {1}\n", Indent(i + 1), c.Print(i + 1));
            }

            return s;
        }
    }
}
